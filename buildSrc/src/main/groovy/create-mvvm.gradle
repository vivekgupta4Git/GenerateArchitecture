import com.squareup.kotlinpoet.FileSpec
import org.gradle.api.Action
import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Nested
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.options.Option

class PluginConstant{
    public static final String PLUGIN_GROUP = "Architecture Plugin"
    public static final String PLUGIN_NAME = "mvvm"
    public static final String M_FOR_MODEL = "model"
    public static final String EXTENSION_PROPERTY_NAME = "name"
    public static final String EXTENSION_PROPERTY_SUB_PATH = "subPath"
    public static final String VM_FOR_VIEW_MODEL = "viewModel"
    public static final String V_FOR_VIEW = "view"
    public static final String EXTENSION_NAME = "mvvmConfig"
}


abstract class GenerateMvvm extends DefaultTask {

    private boolean preferKotlin = true

    private String subPath

    @Option(option = "subPath", description = """Generates mvvm inside the subpath.
    Mvvm generates stuffs under main source directory + package name; 
    so if subPath is given then mainSourceDirectory/packageName/subPath""")
    void setSubPath(String subPath) {
        this.subPath = subPath
    }

    @Option(option = "preferKotlin",description = """ This plugin generates code assuming you have kotlin sourceSets
    but if you have java sourceSets and you want to generate structure in the java sourceSets you can set this flag to false by
    using option :mvvm  --no-preferKotlin""")
    void setPreferKotlin(boolean prefer){
        preferKotlin = prefer
    }

    @TaskAction
    void action() {
        def projectPath
        def mainSourceSet = project.layout.projectDirectory.dir('src/main')
        def kotlinSourceDir = mainSourceSet.dir("kotlin").asFile
        def javaSourceDir = mainSourceSet.dir("java").asFile

        if (kotlinSourceDir.exists() && preferKotlin)
            projectPath = kotlinSourceDir.path
        else
            projectPath = javaSourceDir.path

        def androidExtension = project.extensions.findByName("android")
        //either use findByName or use map getter method
        def namespaceCollection = androidExtension.properties.get("namespace").split('\\.')
        def namespace = ""
        namespaceCollection.each { part ->
            namespace = namespace + "/$part"
        }
        def dirPath
        if (subPath) {
            dirPath = projectPath + namespace + "/${subPath}"
        } else
            dirPath = projectPath + namespace

        def dir = new File(dirPath)
        if (!dir.exists())
            dir.mkdirs()

        println(project.extensions[PluginConstant.EXTENSION_NAME]
                .properties[PluginConstant.M_FOR_MODEL][PluginConstant.EXTENSION_PROPERTY_NAME].get()) //using map getter

        println(project.extensions[PluginConstant.EXTENSION_NAME]
                .properties[PluginConstant.M_FOR_MODEL][PluginConstant.EXTENSION_PROPERTY_SUB_PATH].get()) //using map getter

        println(project.extensions[PluginConstant.EXTENSION_NAME]
                .properties[PluginConstant.VM_FOR_VIEW_MODEL][PluginConstant.EXTENSION_PROPERTY_NAME].get()) //using map getter

        println(project.extensions[PluginConstant.EXTENSION_NAME]
                .properties[PluginConstant.VM_FOR_VIEW_MODEL][PluginConstant.EXTENSION_PROPERTY_SUB_PATH].get()) //using map getter

        println(project.extensions[PluginConstant.EXTENSION_NAME]

                .properties[PluginConstant.V_FOR_VIEW][PluginConstant.EXTENSION_PROPERTY_NAME].get()) //using map getter

        println(project.extensions[PluginConstant.EXTENSION_NAME]
                .properties[PluginConstant.V_FOR_VIEW][PluginConstant.EXTENSION_PROPERTY_SUB_PATH].get()) //using map getter

        def packageName = androidExtension.properties.get("namespace").toString()
        def fileSpec = FileSpec.builder(packageName, "GradleLovesKotlinPoet").build()
        def kotlinFile = new File(dir, "GradleLovesKotlinPoet.kt")
        kotlinFile.withWriter('UTF-8') {
            writer ->
                fileSpec.writeTo(writer)
        }

    }
}


abstract class Mvvm implements Plugin<Project> {
    @Override
    void apply(Project project) {
        def mvvmConfiguration = project.extensions.create(PluginConstant.EXTENSION_NAME, MvvmConfigurationExtension)
        project.tasks.register(PluginConstant.PLUGIN_NAME, GenerateMvvm.class) {
            group = PluginConstant.PLUGIN_GROUP
            description = "Generate directory structure according to Mvvm Architecture"
            mvvmConfiguration.model {
                name.convention("data")
                subPath.convention("")
            }
            mvvmConfiguration.viewModel {
                name.convention("viewModel")
                subPath.convention("")
            }
            mvvmConfiguration.view {
                name.convention("ui")
                subPath.convention("")
            }
        }
    }
}

abstract class MvvmConfigurationExtension {
    @Nested
    abstract Model getModel();

    @Nested
    abstract ViewModel getViewModel();

    @Nested
    abstract View getView()

    void model(Action<? super Model> action) {
        action.execute(getModel())
    }

    void view(Action<? super View> action) {
        action.execute(getView())
    }

    void viewModel(Action<? super ViewModel> action) {
        action.execute(getViewModel())
    }
}


abstract class Model {
    abstract Property<String> getName()

    abstract Property<String> getSubPath()
}

abstract class View {
    abstract Property<String> getName()

    abstract Property<String> getSubPath()
}

abstract class ViewModel {
    abstract Property<String> getName()

    abstract Property<String> getSubPath()
}